from abc import ABC, abstractmethod
from typing import Any, Dict

from langchain_core.documents.base import Document
from langchain_core.language_models.chat_models import BaseChatModel
from langchain_core.messages.ai import AIMessage
from langchain_core.runnables.base import Runnable

from app.services.base import BaseService


class MinimalService(BaseService, ABC):
    """
    An abstract base class for minimal services built on top of a chat model.

    The `MinimalService` class provides a foundation for implementing specific services
    (e.g., summarization, translation, tagging). It defines shared behavior and requires
    subclasses to implement prompts and service types.
    """

    def __init__(self, chatmodel: BaseChatModel, has_system_msg_support: bool = False):
        """
        Initializes the `MinimalService` with a chat model and optional system message support.

        Parameters
        ----------
        chatmodel : BaseChatModel
            The chat model to be used for the service's execution.
        has_system_msg_support : bool, optional
            Indicates whether the chat model supports system messages (default is False).
        """
        self.chatmodel = chatmodel
        self.has_system_msg_support = has_system_msg_support

    @property
    @abstractmethod
    def prompt(self):
        """
        Abstract property to define the prompt template for the service.

        Returns
        -------
        ChatPromptTemplate
            A chat prompt template specific to the service implementation.
        """
        ...

    @property
    @abstractmethod
    def service_type(self) -> str:
        """
        Abstract property to define the service type.

        Returns
        -------
        str
            A string constant representing the type of service.
        """
        ...

    @property
    def message_type(self) -> str:
        """
        Determines the message type for the chat model interaction.

        Returns
        -------
        str
            "system" if system message support is enabled, otherwise "human".
        """
        return "system" if self.has_system_msg_support else "human"

    @property
    def runnable(self) -> Runnable:
        """
        Combines the service's prompt and chat model into a runnable chain.

        Returns
        -------
        Runnable
            A runnable chain consisting of the prompt and the chat model.
        """
        return self.prompt | self.chatmodel

    def run(self, content: list[Document]) -> AIMessage:
        """
        Executes the service by processing the input documents through the runnable chain.

        Parameters
        ----------
        content : list[Document]
            A list of documents to be processed.

        Returns
        -------
        AIMessage
            The output message generated by the chat model.
        """
        return self.runnable.ainvoke({"text": self._get_text_from_content(content=content)})

    def get_metadata(self, file: str, gen_metadata: Dict) -> Dict[str, Any]:
        """
        Retrieves metadata related to the service execution.

        Parameters
        ----------
        file : str
            The name of the file being processed.
        gen_metadata : dict
            Metadata related to the generation process.

        Returns
        -------
        dict[str, Any]
            A dictionary containing metadata, including service type, chat model details,
            prompt details, and system message support status.
        """
        metadata = self._get_base_metadata(file=file, gen_metadata=gen_metadata)
        metadata.update({
            'service_type': self.service_type,
            'chatmodel': repr(self.chatmodel),
            'prompt': repr(self.prompt),
            'has_system_msg_support': self.has_system_msg_support,
        })
        return metadata
